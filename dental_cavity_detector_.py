# -*- coding: utf-8 -*-
"""Dental cavity detector .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xUl3MMMfBdjIdMcyY23sFr3TFQkEtTs7
"""

from google.colab import files
uploaded = files.upload()

import zipfile
# Specify the path of the uploaded zip file
zip_file_path = '/content/archive (1).zip'
# Extract the zip file
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall('/content/sample_data')  # here we Specify the destination folder where the contents will be extracted

!pip install opencv-python
!pip install scikit-learn
!pip install tensorflow
!pip install python-telegram-bot
!pip install pyTelegramBotAPI

import os
import cv2
import numpy as np
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.utils import to_categorical
import telebot
# Set up the dataset path
dataset_path = '/content/dental'
# Preprocess the images
image_paths = []
labels = []
for folder in ['train', 'test']:
    cavity_folder = os.path.join(dataset_path, folder, 'cavity')
    non_cavity_folder = os.path.join(dataset_path, folder, 'no_cavity')
    for image_file in os.listdir(cavity_folder):
        image_paths.append(os.path.join(cavity_folder, image_file))
        labels.append(1)  # Label 1 for cavity

    for image_file in os.listdir(non_cavity_folder):
        image_paths.append(os.path.join(non_cavity_folder, image_file))
        labels.append(0)  # Label 0 for non-cavity
# Preprocess the images
images = []
invalid_images = []
for image_path in image_paths:
    img = cv2.imread(image_path, 0)  # Load the image in grayscale
    if img is not None:  # Check if the image is not empty
        img = cv2.resize(img, (100, 100))  # Resize the image to a desired size
        img = img.reshape((100, 100, 1))  # Reshape the image to add the channel dimension
        images.append(img)
    else:
        invalid_images.append(image_path)
# Convert the image list to a NumPy array
images = np.array(images)
# Remove labels corresponding to invalid images
valid_labels = [label for idx, label in enumerate(labels) if image_paths[idx] not in invalid_images]
valid_labels = to_categorical(valid_labels)
# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(images, valid_labels, test_size=0.2, random_state=42)
# Build the CNN model
model = Sequential()
model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(100, 100, 1)))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Flatten())
model.add(Dense(64, activation='relu'))
model.add(Dense(2, activation='softmax'))
# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
# Train the model
model.fit(X_train, y_train, batch_size=32, epochs=10, validation_data=(X_test, y_test))
# Save the model
model.save('pretrained_model.h5')
# Create a telebot instance
bot = telebot.TeleBot('Your bot id')
@bot.message_handler(commands=['start'])
def handle_start(message):
    bot.send_message(message.chat.id, "Hi! I am a tooth cavity detector bot.Send me image of your tooth")
@bot.message_handler(content_types=['photo'])
def handle_photo(message):
    # Get the file ID of the photo
    file_id = message.photo[-1].file_id
    # Download the photo
    file_info = bot.get_file(file_id)
    downloaded_file = bot.download_file(file_info.file_path)
    # Save the photo
    image_path = 'image.jpg'
    with open(image_path, 'wb') as f:
        f.write(downloaded_file)
    # Perform prediction on the photo
    new_image = cv2.imread(image_path, 0)  # Load the image in grayscale
    if new_image is not None:  # Check if the image is not empty
        new_image = cv2.resize(new_image, (100, 100))  # Resize the image to a desired size
        new_image = new_image.reshape((1, 100, 100, 1))  # Reshape the image to add the batch and channel dimensions
        # Make a prediction
        prediction = model.predict(new_image)
        # Send the prediction result
        if np.argmax(prediction) == 1:
            bot.send_message(message.chat.id, "Cavity is present.")
        else:
            bot.send_message(message.chat.id, "Cavity is not present.")
    else:
        bot.send_message(message.chat.id, "Invalid image.")
# Start the bot
bot.polling()